{
  "version": 3,
  "sources": ["../lib/subscription.js", "../lib/value.js", "../lib/array.js", "../lib/object.js"],
  "sourcesContent": ["export default class Subscription {\n    constructor() {\n        this._subscribers = []\n    }\n\n    subscribe(subscriber) {\n        this._subscribers.push(subscriber)\n    }\n\n    publish(...values) {\n        for (let subscriber of this._subscribers) {\n            subscriber(...values)\n        }\n    }\n\n    // I want to do something like this, but it would cause circular dependencies:\n    static from(item) {\n        if (typeof item === \"object\") {\n            if (Array.isArray(item)) {\n                // return new ReactiveArray(item)\n            } else {\n                // return new ReactiveObject(item)\n            }\n        }\n\n        // return new ReactiveValue(item)\n    }\n}\n", "import Subscription from \"./subscription\";\n\nexport default class ReactiveValue extends Subscription {\n    constructor(initialValue) {\n        super()\n        this._value = initialValue\n    }\n\n    get() {\n        return this._value\n    }\n\n    set(value) {\n        this._value = value\n        this.publish(this._value)\n    }\n\n    static() {\n        return this._value\n    }\n}\n", "import Subscription from \"./subscription\";\n\nexport default class ReactiveArray extends Subscription {\n    constructor(initialArray) {\n        super()\n\n        this._internal = []\n\n        for (const item of initialArray) {\n            // I want to convert the items into their wrapper counterparts, something like:\n            // this._internal.push(Subscription.from(item))\n        }\n    }\n\n    static() {\n        return this._internal.map(item => item.static())\n    }\n\n    // TODO: implement all the stuff\n}\n", "import Subscription from \"./subscription\";\n\nexport default class ReactiveObject extends Subscription {\n    constructor(initialObject) {\n        super()\n\n        this._internal = {}\n\n        for (const key in initialObject) {\n            const value = initialObject[key]\n            // I want to convert the values into their wrapper counterparts, something like:\n            // this._internal[key] = Subscription.from(value)\n        }\n    }\n\n    static() {\n        const _static = {}\n        for (const key in this._internal) {\n            _static[key] = this._internal[key].static()\n        }\n    }\n\n    // TODO: implement all the stuff\n}\n"],
  "mappings": "MAAA,IAAqBA,EAArB,KAAkC,CAC9B,aAAc,CACV,KAAK,aAAe,CAAC,CACzB,CAEA,UAAUC,EAAY,CAClB,KAAK,aAAa,KAAKA,CAAU,CACrC,CAEA,WAAWC,EAAQ,CACf,QAASD,KAAc,KAAK,aACxBA,EAAW,GAAGC,CAAM,CAE5B,CAGA,OAAO,KAAKC,EAAM,CACV,OAAOA,GAAS,UACZ,MAAM,QAAQA,CAAI,CAQ9B,CACJ,ECzBA,IAAqBC,EAArB,cAA2CC,CAAa,CACpD,YAAYC,EAAc,CACtB,MAAM,EACN,KAAK,OAASA,CAClB,CAEA,KAAM,CACF,OAAO,KAAK,MAChB,CAEA,IAAIC,EAAO,CACP,KAAK,OAASA,EACd,KAAK,QAAQ,KAAK,MAAM,CAC5B,CAEA,QAAS,CACL,OAAO,KAAK,MAChB,CACJ,EClBA,IAAqBC,EAArB,cAA2CC,CAAa,CACpD,YAAYC,EAAc,CACtB,MAAM,EAEN,KAAK,UAAY,CAAC,EAElB,QAAWC,KAAQD,EAAc,CAIrC,CAEA,QAAS,CACL,OAAO,KAAK,UAAU,IAAIC,GAAQA,EAAK,OAAO,CAAC,CACnD,CAGJ,ECjBA,IAAqBC,EAArB,cAA4CC,CAAa,CACrD,YAAYC,EAAe,CACvB,MAAM,EAEN,KAAK,UAAY,CAAC,EAElB,QAAWC,KAAOD,EAAe,CAC7B,IAAME,EAAQF,EAAcC,CAAG,EAIvC,CAEA,QAAS,CACL,IAAME,EAAU,CAAC,EACjB,QAAWF,KAAO,KAAK,UACnBE,EAAQF,CAAG,EAAI,KAAK,UAAUA,CAAG,EAAE,OAAO,CAElD,CAGJ",
  "names": ["Subscription", "subscriber", "values", "item", "ReactiveValue", "Subscription", "initialValue", "value", "ReactiveArray", "Subscription", "initialArray", "item", "ReactiveObject", "Subscription", "initialObject", "key", "value", "_static"]
}
